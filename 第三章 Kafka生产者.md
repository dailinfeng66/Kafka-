## 创建Kafka生产者

+ 要往kafka中写入数据，首先要创建一个生产者对象，并设置一些属性。

+ kafka生产者有3个必选属性。  其他的不写的话就是使用默认的方式

  + bootstrap.servers  该属性指定broker的地址清单，地址的格式为ip：port，生产者会从一个broker里面获取到其他broker的信息，不过还是建议最好写两个broker的信息，因为如果一个dawn了的情况下，还有另一个可以使用和获取信息。

  + key.serializer  broker希望接收到的消息的键和值都是字节数组。 -> 一句话 就是指定键的序列化方式而已

  + value.serializer 同上理。指定值的序列化方式而已

    ps： 如果用kafka传对象的话还要自己去实现序列化方式那些，感觉并不是很好用，推荐直接把对象转为json字符串 用string的序列化方式

+ 生产者发送消息有3种方式：

  + 发送并忘记（fire-and-forget)：把消息发送给服务器，但是并不关心它是否能够正常到达。使用这种方式有时候也会丢失一些信息。
  + 同步发送： 我们使用send() 方法发送信息，他会返回一个future对象，调用get()方法进行等待，就可以知道消息是否发送成功。
  + 异步发送：我们调用send()方法并指定一个回调函数，服务器在返回相应时调用该函数。
  + 总结区别：调用了get的是同步 不调用的是发送并忘记，有回调的是异步

## 生产者的配置

生产者还有很多可以配置的参数，他们大多数都有较为合理的默认值。所以没有必要去修改他们。不过有几个参数在内存使用、性能和可靠性方面对生产者的影响比较大。

+ acks： 这个参数指定了必须有多少个分区副本来接收消息，生产者才会认为消息是发送成功的。
  + acks=0: 生产者在成功写入消息之前不会等待任何来自服务器的响应。也就是说即使是服务器没有收到消息生产者也是无从得知的。
    + 缺点：消息很容易丢失。
    + 优点：因为生产者不需要等待服务器的响应，因此他可以以网络能够支持的最大速度发送消息，从而达到很高的吞吐量。
  + acks=1: 只要集群的首领节点收到消息，生产者就会收到一个来自服务器的成功响应。如果消息无法达到首领节点，生产者会收到一个错误响应，并且会重新发送消息。不过如果一个没有收到消息的节点成为新首领，消息还是会丢失。  **此时吞吐里取决于消息发送的方式是同步还是异步**
  + acks=all:只有当所有参与复制的节点全部收到消息时，生产者才会收到一个来自服务器的成功响应。**这种模式是最安全的**，他可以保证不止一个服务器收到消息，就算有服务器发生了崩溃，整个集群仍然可以运行。

