## 消费者和消费者群组

如果生产者生产的速度超过了消费者消费处理的速度，这个时候就得横向的扩张消费者。就像多个生产者可以向相同的主题写入消息一样，我们也可以使用多个消费者从同一个主题读取消息，对消息进行分流。

kafka消费者从属于**消费者群组**。一个群组里面的消费者订阅的是同一个主题，每个消费者接收主题一部分分区消息。

**如果一个主题T1被一个分区里面的几个消费者同时读取的话，是每个消费者读取一个分区的形式，如果两个消费者群组对一个主题进行读取的话消息是被两个消费者群组同时读取的 **

## 消费者群组和分区再均衡

分区的所有权从一个消费者转移到另一个消费者，这样的行为成为**再均衡**。再均衡为消费者群组带来了**高可用性和伸缩性**

## 轮训

消费者获取消息，发送心跳都是通过轮训的方式实现的。

## 消费者的配置

+ fetch.min.bytes:该属性制定了消费者从服务器获取记录数的最小字节数，broker在收到消费者的数据请求时，如果可用的数据量小于fetch.min.bytes指定的大小，那么他会等到有足够的可用数据时才会把它放回给消费者。（主要是降低消费者和broker的负载）一句话概括功能就是告诉kafka等到有足够多的数据时才返回。
+ fetch.max.wait.ms:指定broker的等待时间，默认是500ms，也就是没达到最小的返回阈值（fetch.min.bytes）。如果没有足够的数据流入kafka，最终导致等待时间延迟，则可以改小阈值或增大等待时间。
+ max.partition.fetch.bytes:该属性指定了服务器从每个分区返回给消费者的最大字节数。他的默认是1MB。max.partition.fetch.bytes的值必须比broker能够接收的最大消息的字节数大（通过max.message.size设置)，否则消费者可能无法读取这些消息，导致消费者一直挂起重试。
+ session.timeout.ms:该属性指定了消费者在被认为死亡之前可以与服务器断开连接的时间，默认是3s。如果消费者没有在这个时间之内发送心跳给群组协调器，就被认为已经死亡，协调器就会出发再均衡，把它的分区分配给群组里的其他消费者。
  + headbeat.interval.ms指定了poll方法向协调器发送心跳的频率，所以一般这两个配置同时修改，headbeat.interval.ms要比session.timeout.ms小，一般是它的三分之一。
+ auto.offset.reset:该属性指定了消费者在读取一个没有偏移量的分区，或偏移量无效的情况下（因为消费者长时间失效，包含偏移量的记录已经过时并被删除）该作何处理。他的默认值是latest，
  + latest：在偏移量无效的情况下，消费者将从最新的记录开始读取数据（消费者启动之后生成的数据）
  + earlist：在偏移量无效的情况下，消费者将从起始位置读取分区数据。
+ enable.auto.commit:该属性指定了消费者是否自动提交偏移量，默认值是true，为了避免数据丢失可以设置为false，由自己控制何时提交偏移量，如果设置为true可以通过配置auto.commit.interval.ms属性来控制提交的频率。
+ partition.assignment.strategy:kafka分区分配给消费者的策略。
  + Range：该策略会把若干个连续的分区分配给消费者。
  + RoundRobin：该策略把主题的所有分区逐个分配给消费者。也就是一人一个的来。
+ client.id:该属性可以是任意字符串，broker用它来标识从客户端发过来的消息，通常被用在日志、度量指标和配额里。
+ max.poll.records:该属性用于控制单次调用call（）方法能够返回的记录数量，可以帮你控制在轮询里需要处理的数据量。
+ receive.buffer.bytes和send.buffer.bytes:socket在读写数据时用到的tcp缓冲区也可以设置大小。如果它们被设置为-1，就使用操作系统的默认值。如果生产者或消费者与broker处于不同的数据中心内，可以适当增大这些值，因为跨数据中心的网络一般都有比较高的延迟和比较低的带宽。

## 提交和偏移量

消费者可以使用kafka来追踪消息在分区里面的位置–也就是偏移量。

如果消费者一直处在运行状态偏移量就没有用处，kafka消息消费并不是消费一条这一条就删除了的，因此需要一个偏移量来确定目前消息是读取到了那一条，所以才会有偏移量这个东西，当消费者上线之后读取偏移量，根据偏移量来获取开始读取消息的位置。

+ 自动提交：就是把自动提交的配置改为true，那么每过5s消费者就会提交接收到的最大偏移量。自动提交是在轮询里面进行的。	
  + 带来的结果：可能会被重复处理，
    + eg：5s提交偏移量，但是在最近提交之后的3s发生了再均衡，再均衡之后就会从最后一次提交的偏移量开始读取消息。这个时候偏移量已经落后了3s，因此这3s的消息将会被重复处理
+ 提交当前偏移量：开发者可以在必要的时间手动提交偏移量。首先把自动提交偏移量关了。
  + 不足之处：在broker对提交请求作出回应之前，应用程序会一直阻塞。
+ 异步提交偏移量、同步和异步组合提交偏移量
+ 提交特定的偏移量：一次性拉下来一大批消息，想处理的过程中提交偏移量的时候使用。
+ 再均衡监听器
+ 从特定的偏移量处开始处理数据
+ 



